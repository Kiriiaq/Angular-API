"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateWithCustomTemplate = exports.updateCustom = void 0;
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const os_1 = require("os");
const get_spec_file_name_1 = require("../common/get-spec-file-name");
const paths_1 = require("../common/paths");
const read_1 = require("../common/read/read");
const scuri_custom_update_template_1 = require("../common/scuri-custom-update-template");
const types_1 = require("../types");
function updateCustom(o) {
    return (tree, context) => {
        var _a, _b;
        const template = (_a = tree.read(o.classTemplate)) === null || _a === void 0 ? void 0 : _a.toString('utf8');
        const fileUnderTestContent = (_b = tree.read(o.name)) === null || _b === void 0 ? void 0 : _b.toString('utf8');
        if (typeof fileUnderTestContent === 'string' && typeof template === 'string') {
            const r = (0, read_1.describeSource)(o.name, fileUnderTestContent);
            const topClass = Array.isArray(r) ? r[0] : {};
            if ((0, types_1.isClassDescription)(topClass)) {
                const { constructorParams, publicMethods } = topClass;
                const { specFileName, fileName: normalizedName, folderPathNormal: folder } = (0, paths_1.paths)(o.name);
                const classData = Object.assign(Object.assign({}, core_1.strings), { className: topClass.name, name: topClass.name, specFileName, normalizedName: normalizedName, folder, constructorParams: 'not available for update - please use `params`', declaration: 'not available for update - specific for scuri original style testing', builderExports: 'not available for update - builder is specific for scuri original style testing - the setup function with a builder', params: constructorParams, publicMethods: publicMethods, shorthand: (normalizedName !== null && normalizedName !== void 0 ? normalizedName : '')[0].toLowerCase() });
                const customSpecFileName = (0, get_spec_file_name_1.getSpecFileCustomName)(classData, o.classTemplate);
                const customSpecFileContents = customSpecFileName != null ? tree.read(customSpecFileName) : null;
                if (customSpecFileContents != null) {
                    const inserts = updateWithCustomTemplate(Object.assign(Object.assign({}, classData), { specFileContents: customSpecFileContents.toString('utf8'), templateContents: template }), context);
                    const recorder = tree.beginUpdate(customSpecFileName);
                    inserts.forEach((a) => {
                        recorder.insertLeft(a.position, a.content);
                    });
                    tree.commitUpdate(recorder);
                }
                else {
                    context.logger.error(`Looks like the custom spec file ${customSpecFileName} does not exist. Try creating the file before updating it.`);
                }
            }
            else {
                context.logger.error(`Looks like there was no class in ${o.name}`);
            }
        }
        else {
            if (typeof fileUnderTestContent !== 'string') {
                context.logger.error(`Looks like the file ${o === null || o === void 0 ? void 0 : o.name} is missing or invalid.`);
            }
            if (typeof template !== 'string') {
                context.logger.error(`Looks like the file ${o === null || o === void 0 ? void 0 : o.classTemplate} is missing or invalid.`);
            }
        }
        return tree;
    };
}
exports.updateCustom = updateCustom;
const skip = '-skipDeDupe';
// todo - check for each error condition and report
function updateWithCustomTemplate(templateData, context) {
    const [_, parts] = (0, scuri_custom_update_template_1.updateCustomTemplateCut)(templateData.templateContents);
    const originalMethods = templateData.publicMethods;
    // skip methods that already have tests
    templateData.publicMethods = originalMethods.filter((pm) => !templateData.specFileContents.includes(pm));
    if (templateData.publicMethods.length !== originalMethods.length) {
        context.logger.debug(`Skipping methods: [${originalMethods
            .filter((m) => !templateData.publicMethods.includes(m))
            .join(',')}] as they seem to be already in the spec.`);
    }
    // curry (e.g. prepare) the template fn with the context (templateData)
    const templateFn = (0, schematics_1.applyContentTemplate)(templateData);
    return parts
        .map((p) => {
        var _a, _b;
        const mark = `// scuri:${p.mark.replace(skip, '')}`;
        const template = {
            path: (0, core_1.normalize)('.'),
            content: Buffer.from(p.template),
        };
        const templateResult = (_b = (_a = templateFn(template)) === null || _a === void 0 ? void 0 : _a.content.toString('utf8')) !== null && _b !== void 0 ? _b : '';
        if (templateResult === '') {
            context.logger.debug(`No result from applying template for ${p.mark}.`);
        }
        else {
            context.logger.debug(`Template result before de-duplication: [${templateResult}]`);
        }
        const spaces = getWhitespaceBefore(templateData.specFileContents, mark);
        // skip de-duplication for the whole section (mark)
        const skipDeDupe = p.mark.includes(skip);
        const deDupedContent = templateResult
            .split(/\r\n|\r|\n/g)
            // remove lines of code that are already in the spec
            .filter((c) => skipDeDupe || !templateData.specFileContents.includes(c))
            .join(`${os_1.EOL}${spaces}`);
        const position = templateData.specFileContents.indexOf(mark);
        // add the space at the end
        return { position, content: `${deDupedContent}${os_1.EOL}${spaces}` };
    })
        .filter((a) => !templateData.specFileContents.includes(a.content));
}
exports.updateWithCustomTemplate = updateWithCustomTemplate;
function getWhitespaceBefore(content, mark) {
    var _a;
    const spacesOrEmpty = (_a = content.match(new RegExp(`^.*${mark}`, 'gm'))) !== null && _a !== void 0 ? _a : [''];
    return spacesOrEmpty[0].replace(mark, '');
}
//# sourceMappingURL=index.js.map