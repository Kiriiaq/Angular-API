"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.spec = void 0;
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const cosmiconfig_1 = require("cosmiconfig");
const os_1 = require("os");
const path_1 = require("path");
const change_1 = require("../../lib/utility/change");
const get_spec_file_name_1 = require("../common/get-spec-file-name");
const paths_1 = require("../common/paths");
const read_1 = require("../common/read/read");
const scuri_custom_update_template_1 = require("../common/scuri-custom-update-template");
const types_1 = require("../types");
const update_1 = require("./update/update");
class SpecOptions {
}
function spec({ name, update, classTemplate, functionTemplate, config }) {
    return (tree, context) => {
        var _a;
        const logger = context.logger.createChild('scuri.index');
        logger.debug(`Params: name: ${name} update: ${update} classTemplate: ${classTemplate} config: ${config}`);
        let c = {};
        try {
            const res = config ? (0, cosmiconfig_1.cosmiconfigSync)('scuri').load(config) : (0, cosmiconfig_1.cosmiconfigSync)('scuri').search();
            c = (_a = res === null || res === void 0 ? void 0 : res.config) !== null && _a !== void 0 ? _a : {};
        }
        catch (e) {
            //  the config file is apparently missing/malformed (as per https://www.npmjs.com/package/cosmiconfig#explorersearch)
            logger.debug(e === null || e === void 0 ? void 0 : e.stack);
            throw new Error(`Looks like the configuration was missing/malformed. ${e === null || e === void 0 ? void 0 : e.message}`);
        }
        classTemplate = classTemplate !== null && classTemplate !== void 0 ? classTemplate : c.classTemplate;
        if (typeof classTemplate === 'string' && !tree.exists(classTemplate)) {
            throw new Error(`Class template configuration was [${(0, path_1.resolve)(classTemplate)}] but that file seems to be missing.`);
        }
        functionTemplate = functionTemplate !== null && functionTemplate !== void 0 ? functionTemplate : c.functionTemplate;
        if (typeof functionTemplate === 'string' && !tree.exists(functionTemplate)) {
            throw new Error(`Function template configuration was [${(0, path_1.resolve)(functionTemplate)}] but that file seems to be missing.`);
        }
        try {
            if (update) {
                if (classTemplate) {
                    return (0, schematics_1.schematic)('update-custom', { name, classTemplate });
                }
                return updateExistingSpec(name, tree, logger);
            }
            else {
                return createNewSpec(name, tree, logger, { classTemplate, functionTemplate });
            }
        }
        catch (e) {
            e = e || {};
            logger.error(e.message || 'An error occurred');
            logger.debug(`---Error--- ${os_1.EOL}${e.message || 'Empty error message'} ${e.stack || 'Empty stack.'}`);
        }
    };
}
exports.spec = spec;
function sliceSpecFromFileName(path) {
    if (path.includes('.spec')) {
        return path.replace('.spec', '');
    }
    else {
        return path;
    }
}
function updateExistingSpec(fullName, tree, logger) {
    const specFileName = sliceSpecFromFileName(fullName);
    const content = tree.read(specFileName);
    if (content == null) {
        logger.error(`The file ${specFileName} is missing or empty.`);
    }
    else {
        // the new spec full file name contents - null if file not exist
        const existingSpecFile = tree.get((0, get_spec_file_name_1.getSpecFilePathName)(specFileName));
        if (existingSpecFile == null) {
            logger.error(`Can not update spec (for ${specFileName}) since it does not exist. Try running without the --update flag.`);
        }
        else {
            const specFilePath = existingSpecFile.path;
            // if a spec exists we'll try to update it
            const { params, name, publicMethods } = getFirstClass(specFileName, content);
            const shorthand = typeShorthand(name);
            logger.debug(`Class name ${name} ${os_1.EOL}Constructor(${params}) {${publicMethods}}`);
            // start by adding missing things (like the setup function)
            const addMissingChanges = (0, update_1.addMissing)(specFilePath, tree.read(specFilePath).toString('utf8'), params, name);
            applyChanges(tree, specFilePath, addMissingChanges, 'add');
            // then on the resulting tree - remove unneeded deps
            const removeChanges = (0, update_1.update)(specFilePath, tree.read(specFilePath).toString('utf8'), params, name, 'remove', publicMethods, shorthand);
            applyChanges(tree, specFilePath, removeChanges, 'remove');
            // then add what needs to be added (new deps in the instantiation, 'it' for new methods, etc.)
            const changesToAdd = (0, update_1.update)(specFilePath, tree.read(specFilePath).toString('utf8'), params, name, 'add', publicMethods, shorthand);
            applyChanges(tree, specFilePath, changesToAdd, 'add');
            return tree;
        }
    }
}
function applyChanges(tree, specFilePath, changes, act) {
    const recorder = tree.beginUpdate(specFilePath);
    if (act === 'add') {
        changes
            .filter((c) => c instanceof change_1.InsertChange)
            .forEach((change) => {
            recorder.insertLeft(change.order, change.toAdd);
        });
    }
    else {
        changes
            .filter((c) => c instanceof change_1.RemoveChange)
            .forEach((change) => {
            recorder.remove(change.order, change.toRemove.length);
        });
    }
    tree.commitUpdate(recorder);
}
function createNewSpec(fileNameRaw, tree, logger, o) {
    const content = tree.read(fileNameRaw);
    if (content == null) {
        logger.error(`The file ${fileNameRaw} is missing or empty.`);
    }
    else {
        // we aim at creating a spec from the class/function under test (name)
        // for the spec name we'll need to parse the base file name and its extension and calculate the path
        const { specFileName, fileName, folderPathRaw: path, folderPathNormal: folder } = (0, paths_1.paths)(fileNameRaw);
        let templateVariables;
        try {
            const { params, name, publicMethods } = getFirstClass(fileNameRaw, content);
            // if there are no methods in the class - let's add one test case anyway
            if (Array.isArray(publicMethods) && publicMethods.length === 0) {
                publicMethods.push('');
            }
            const shorthand = typeShorthand(name);
            templateVariables = Object.assign(Object.assign({}, core_1.strings), { 
                // the name of the new spec file
                specFileName, normalizedName: fileName, name, className: name, folder,
                publicMethods,
                params, declaration: toDeclaration(), builderExports: toBuilderExports(), constructorParams: toConstructorParams(), shorthand });
            const src = maybeUseCustomTemplate(tree, (0, schematics_1.url)('./files/class'), o === null || o === void 0 ? void 0 : o.classTemplate);
            const templateSource = (0, schematics_1.apply)(src, [
                (0, schematics_1.applyTemplates)(templateVariables),
                (0, schematics_1.move)(path),
            ]);
            return (0, schematics_1.mergeWith)(templateSource);
            /**
             * End of the create function
             * Below are the in-scope functions
             */
            // functions defined in the scope of the else to use params and such
            // for getting called in the template - todo - just call the functions and get the result
            function toConstructorParams() {
                return params.map((p) => p.name).join(',');
            }
            function toDeclaration() {
                return params
                    .map((p) => p.type === 'string' || p.type === 'number'
                    ? `let ${p.name}:${p.type};`
                    : `const ${p.name} = autoSpy(${p.type});`)
                    .join(os_1.EOL);
            }
            function toBuilderExports() {
                return params.length > 0
                    ? params
                        .map((p) => p.name)
                        .join(',' + os_1.EOL)
                        .concat(',')
                    : '';
            }
        }
        catch (e) {
            if (e != null && e.message === 'No classes found to be spec-ed!') {
                const funktion = getFirstFunction(fileNameRaw, content);
                if (funktion == null) {
                    throw new Error('No exported class or function to be spec-ed!');
                }
                const src = maybeUseCustomTemplate(tree, (0, schematics_1.url)('./files/function'), o === null || o === void 0 ? void 0 : o.functionTemplate);
                const templateSource = (0, schematics_1.apply)(src, [
                    (0, schematics_1.applyTemplates)(Object.assign(Object.assign({}, core_1.strings), { 
                        // the name of the new spec file
                        specFileName,
                        fileName, normalizedName: fileName, name: funktion.name })),
                    (0, schematics_1.move)(path),
                ]);
                return (0, schematics_1.mergeWith)(templateSource);
            }
            else {
                throw e;
            }
        }
    }
}
function maybeUseCustomTemplate(tree, src, templateFileName) {
    if (typeof templateFileName === 'string' && tree.exists(templateFileName)) {
        const template = tree.read(templateFileName);
        if (template != null) {
            const [rest] = (0, scuri_custom_update_template_1.updateCustomTemplateCut)(template.toString('utf8'));
            const t = schematics_1.Tree.empty();
            t.create((0, core_1.basename)((0, core_1.normalize)(templateFileName)), rest);
            src = (0, schematics_1.source)(t);
        }
    }
    return src;
}
function getFirstClass(fileName, fileContents) {
    const descriptions = (0, read_1.describeSource)(fileName, fileContents.toString('utf8'));
    const classes = descriptions.filter((c) => (0, types_1.isClassDescription)(c));
    // we'll take the first class with any number of constructor params or just the first if there are none
    const classWithConstructorParamsOrFirst = classes.filter((c) => c.constructorParams.length > 0)[0] || classes[0];
    if (classWithConstructorParamsOrFirst == null) {
        throw new Error('No classes found to be spec-ed!');
    }
    const { constructorParams: params, name, publicMethods, type, } = classWithConstructorParamsOrFirst;
    return { params, name, publicMethods, type };
}
function getFirstFunction(fileName, fileContents) {
    const descriptions = (0, read_1.describeSource)(fileName, fileContents.toString('utf8'));
    return descriptions.filter((f) => f.type === 'function')[0];
}
function typeShorthand(name) {
    return typeof name === 'string' && name.length > 0 ? name.toLocaleLowerCase()[0] : 'x';
}
//# sourceMappingURL=index.js.map