"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.update = exports.addMissing = exports.i = void 0;
const os_1 = require("os");
const ts = require("../../../lib/third_party/github.com/Microsoft/TypeScript/lib/typescript");
const ast_utils_1 = require("../../../lib/utility/ast-utils");
const change_1 = require("../../../lib/utility/change");
exports.i = ast_utils_1.insertAfterLastOccurrence;
function addMissing(path, fileContent, _dependencies, classUnderTestName) {
    const source = ts.createSourceFile(path, fileContent, ts.ScriptTarget.Latest, true);
    const setupFunctionNode = readSetupFunction(source);
    let missingThings = [];
    if (setupFunctionNode == null) {
        missingThings.push(new change_1.InsertChange(path, source.end, `
function setup() {
    const builder = {
        default() {
            return builder;
        },
        build() {
            return new ${classUnderTestName}();
        }
    }
    return builder;
}`));
    }
    return missingThings;
}
exports.addMissing = addMissing;
function update(path, fileContent, dependencies, classUnderTestName, action, publicMethods, shorthand) {
    const source = ts.createSourceFile(path, fileContent, ts.ScriptTarget.Latest, true);
    const setupFunctionNode = readSetupFunction(source);
    if (setupFunctionNode == null) {
        throw new Error("There is no setup function in the source file. We can't update that.");
    }
    const currentParams = readCurrentParameterNames(setupFunctionNode, classUnderTestName);
    const paramsToRemove = currentParams.filter(p => !dependencies.some(d => d.name === p));
    const paramsToAdd = dependencies.filter(d => !currentParams.some(c => c === d.name));
    return action === 'remove'
        ? remove(paramsToRemove, setupFunctionNode, path)
        : [
            ...add(paramsToAdd, setupFunctionNode, path, classUnderTestName),
            ...addMethods(publicMethods, path, fileContent, source, shorthand),
            ...addMissingImports(dependencies, path, source),
            ...addProviders(source, dependencies, setupFunctionNode.name.getText() || 'setup', path)
        ];
}
exports.update = update;
function readSetupFunction(source) {
    // FunctionDeclaration -> function setup () {/*body*/ }
    return (0, ast_utils_1.findNodes)(source, ts.SyntaxKind.FunctionDeclaration).find(n => n.name != null && n.name.text.startsWith('setup'));
}
function readCurrentParameterNames(setupFunctionNode, classUnderTestName) {
    // NewExpression -> new ExampleComponent(dep1, dep2)
    const instantiateClassUnderTestNode = (0, ast_utils_1.findNodes)(setupFunctionNode, ts.SyntaxKind.NewExpression).find(node => node.kind === ts.SyntaxKind.NewExpression && node.getText().includes(classUnderTestName));
    //  SyntaxList -> dep1,dep2
    const parametersList = (0, ast_utils_1.findNodes)(instantiateClassUnderTestNode, ts.SyntaxKind.SyntaxList)[0];
    // Array -> ['dep1', 'dep2']
    const parameterNames = (0, ast_utils_1.findNodes)(parametersList, ts.SyntaxKind.Identifier).map(n => n.getText());
    return parameterNames;
}
function remove(toRemove, setupFunction, path) {
    // VariableStatement -> let dep:string; Or const service = autoSpy(Object);
    const instantiations = (0, ast_utils_1.findNodes)(setupFunction, ts.SyntaxKind.VariableStatement).filter((n) => n.declarationList.declarations.some(v => toRemove.includes(v.name.getText())));
    const uses = (0, ast_utils_1.findNodes)(setupFunction, ts.SyntaxKind.Identifier)
        .filter(i => !i.parent || i.parent.kind !== ts.SyntaxKind.VariableDeclaration)
        .filter(i => toRemove.includes(i.getText()));
    return instantiations
        .concat(uses)
        .map(i => new change_1.RemoveChange(path, i.pos, getTextPlusCommaIfNextCharIsComma(i)));
}
/**
 * Since we want to remove some content from the file it might be the case that there is a comma right after it.
 * In that case we want to remove the comma too
 * @param i the node to read
 * @example *
 * var t = new Class(toRemove, toKeep) // -> we want to remove [toRemove,] <- plus the comma
 * var t = new Class(toKeep)
 */
function getTextPlusCommaIfNextCharIsComma(i) {
    const nextSymbol = i.getSourceFile().getFullText()[i.getEnd()];
    let text = i.getFullText();
    if (nextSymbol === ',') {
        text += nextSymbol;
    }
    return text;
}
function add(toAdd, setupFunction, path, classUnderTestName) {
    // children of the setup include the block - that's what we want to change
    const block = setupFunction.getChildren().find(c => c.kind === ts.SyntaxKind.Block);
    if (block == null) {
        throw new Error('Could not find the block of the setup function.');
    }
    return [
        ...declareNewDependencies(block, toAdd, path),
        ...exposeNewDependencies(block, toAdd, path),
        ...useNewDependenciesInConstructor(block, toAdd, path, classUnderTestName)
    ];
}
function declareNewDependencies(block, toAdd, path, _indentation) {
    // children of the block are the opening { [at index [0]], the block content (SyntaxList) [at index[1]] and the closing } [index [2]]
    // we want to update the SyntaxList
    const setupBlockContent = block.getChildAt(1);
    // leading because it includes the end-of-line from previous line plus indentation on current line
    const leadingIndent = getIndentationMinusComments(setupBlockContent);
    const position = setupBlockContent.getStart();
    return toAdd.map(p => 
    // if we are 'mocking' a simple/native type - let c: string; / let c: Object; - leave the instantiation till later
    // if it's a complex type -> const c = autoSpy(Service);
    new change_1.InsertChange(path, position, p.type === 'string' ||
        p.type === 'number' ||
        p.type === 'any' ||
        p.type === 'unknown' ||
        p.type === 'Object'
        ? `let ${p.name}: ${p.type};` + leadingIndent
        : `const ${p.name} = autoSpy(${p.type});` + leadingIndent));
}
function exposeNewDependencies(block, toAdd, path) {
    const builderDeclaration = (0, ast_utils_1.findNodes)(block, ts.SyntaxKind.VariableDeclaration).find(v => v.name.getFullText().includes('builder'));
    const builderObjectLiteral = (0, ast_utils_1.findNodes)(builderDeclaration, ts.SyntaxKind.ObjectLiteralExpression)[0];
    if (builderDeclaration == null || builderObjectLiteral == null) {
        throw new Error('Could not find the builder declaration or its object literal.');
    }
    const indentation = getIndentationMinusComments(builderObjectLiteral.getChildAt(1));
    const positionToAdd = builderObjectLiteral.getChildAt(0).getEnd();
    return toAdd.map(a => new change_1.InsertChange(path, positionToAdd, `${indentation}${a.name},`));
}
function useNewDependenciesInConstructor(block, toAdd, path, classUnderTestName) {
    const classUnderTestConstruction = (0, ast_utils_1.findNodes)(block, ts.SyntaxKind.NewExpression).find((n) => n.getText().includes(classUnderTestName));
    if (classUnderTestConstruction == null) {
        throw new Error(`Could not find the new ${classUnderTestName}() expression. Can not update spec.`);
    }
    const constrParams = (0, ast_utils_1.findNodes)(classUnderTestConstruction, ts.SyntaxKind.SyntaxList)[0];
    const hasOtherParams = constrParams.getChildCount() > 0;
    return toAdd && toAdd.length > 0
        ? [
            new change_1.InsertChange(path, classUnderTestConstruction.end - 1, (hasOtherParams ? ', ' : '') + toAdd.map(p => p.name).join(', '))
        ]
        : []; // dont add params in constructor if no need to
}
function addMethods(publicMethods, path, fileContent, source, shorthand) {
    const methodsThatHaveNoTests = publicMethods.filter(
    // search for invokations of the method (c.myMethod) - these are inevitable if one wants to actually test the method...
    m => !fileContent.match(new RegExp(`.${m}`)));
    let lastClosingBracketPositionOfDescribe = (0, ast_utils_1.findNodes)(source, ts.SyntaxKind.CallExpression, 100, true)
        .map(e => e.expression)
        // we get all describes calls
        .filter(i => i.getText() === 'describe')
        // then their parent - the expression (it has the body with the curly brackets)
        .map(c => c.parent)
        // then we flat the arrays of all close brace tokens from those bodies
        .reduce((acc, c) => [...acc, ...(0, ast_utils_1.findNodes)(c, ts.SyntaxKind.CloseBraceToken, 100, true)], [])
        // finally get the last brace position
        .reduce((lastClosingBracket, n) => {
        return n.pos > lastClosingBracket ? n.pos : lastClosingBracket;
    }, 0);
    return methodsThatHaveNoTests.map(m => new change_1.InsertChange(path, lastClosingBracketPositionOfDescribe, `${os_1.EOL}    it('when ${m} is called it should', () => {${os_1.EOL}        // arrange${os_1.EOL}        const { build } = setup().default();${os_1.EOL}        const ${shorthand} = build();${os_1.EOL}        // act${os_1.EOL}        ${shorthand}.${m}();${os_1.EOL}        // assert${os_1.EOL}        // expect(${shorthand}).toEqual${os_1.EOL}    });`));
}
function addMissingImports(dependencies, path, source) {
    // build a map of duplicate/first for each entry, based on the whether or not `previous` contains the elements
    const { duplicateMap } = dependencies.reduce((r, n) => {
        r.duplicateMap.set(n, r.previous.some(p => p.type === n.type && p.importPath === n.importPath)
            ? 'duplicate'
            : 'first');
        r.previous = [...r.previous, n];
        return r;
    }, {
        previous: [],
        duplicateMap: new Map()
    });
    return dependencies
        .filter(d => d.importPath != null)
        .filter(d => duplicateMap.get(d) === 'first')
        .filter(d => !(0, ast_utils_1.isImported)(source, d.type, d.importPath))
        .map(d => (0, ast_utils_1.insertImport)(source, path, d.type, d.importPath));
}
/**
 * Should look around for the TestBed configure and update that.
 * If there is no setup call (or there is but it's destructured) it will add a `const a = setup().default()`
 * For each missing provider it will add `.overrideProvider(type, {useValue: a.[name]})`
 * (easier that way instead of picking through the vast number of combinations of the configure testing module)
 *
 * @param source the source created from the file text
 * @param params the constructor parameters of the class-under-test
 * @param setupFunctionName what's the setup function name (default setup)
 * @param path the path to the file
 */
function addProviders(source, params, setupFunctionName, path) {
    const configureTestingModuleCall = (0, ast_utils_1.findNodes)(source, ts.SyntaxKind.CallExpression, 5000, true)
        // reverse to find the innermost callExpression (the configureTestingModule)
        .reverse()
        .find(n => {
        const text = n.getText();
        return text.includes('configureTestingModule') && text.includes('TestBed');
    });
    if (configureTestingModuleCall == null) {
        // this is apparently not using TestBed.configureTestingModule() so nothing to do here
        return [];
    }
    else {
        // find the block of the method that declared TestBed (usually beforeEach)
        const block = findTheParentBlock(configureTestingModuleCall);
        // as well as the position right at the end of the first brace (so we could insert setup call if necessary)
        const openingBracketPosition = block.getChildAt(0).end;
        const firstChildIndentation = getIndentationMinusComments(block.getChildAt(1));
        // if setup function is called - take the name
        const setupInstance = (0, ast_utils_1.findNodes)(block, ts.SyntaxKind.VariableDeclaration).find(n => n.getText().includes('setup'));
        const hasANamedSetupInstance = setupInstance != null &&
            setupInstance.name.kind === ts.SyntaxKind.Identifier;
        // if the setup is not called or its value is not assigned to a variable (e.g. is destructured)
        const a = hasANamedSetupInstance
            ? setupInstance.name.getText()
            : 'a';
        // insert a call to setup function
        const inserts = !hasANamedSetupInstance
            ? [
                new change_1.InsertChange(path, openingBracketPosition, `${firstChildIndentation}const ${a} = ${setupFunctionName}().default();`)
            ]
            : [];
        // calculate which dependencies we need to add
        const configureText = configureTestingModuleCall.getText();
        const depsToAdd = params.filter(p => !configureText.includes(p.type));
        // and then add all missing deps in one configureTestingModule call with providers only
        if (depsToAdd.length > 0) {
            const newProviders = depsToAdd
                .map(d => `{ provide: ${d.type}, useValue: ${a}.${d.name} }`)
                .join(',' + os_1.EOL + '            ');
            inserts.push(new change_1.InsertChange(path, configureTestingModuleCall.end, `.configureTestingModule({ providers: [${newProviders}] })`));
        }
        return inserts;
    }
}
function findTheParentBlock(node) {
    if (node == null || node.kind === ts.SyntaxKind.Block) {
        return node;
    }
    else {
        return findTheParentBlock(node.parent);
    }
}
function getIndentationMinusComments(node) {
    if (node == null) {
        return '';
    }
    const leadingTrivia = node.getFullText().replace(node.getText(), '');
    let index = leadingTrivia.indexOf(os_1.EOL);
    return index < 0 ? leadingTrivia : leadingTrivia.slice(index);
}
//# sourceMappingURL=update.js.map