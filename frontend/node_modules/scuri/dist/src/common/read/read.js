"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.describeSource = void 0;
const ts = require("../../../lib/third_party/github.com/Microsoft/TypeScript/lib/typescript");
const types_1 = require("../../types");
/**
 * Will read the Abstract Syntax Tree of the `fileContents` and extract from that:
 *  - the names and types of all constructors' parameters
 *  - the names of all public method
 *  - the path to the dependencies
 * @example
 * class Test {
 *  constructor(service: MyService, param: string) { }
 *
 *  async future() {}
 *  now() {}
 * }
 * // result would be
 * {
 *  name: 'Test',
 *  constructorParams: [{name: 'service', type:'MyService', importPath:'../../my.service.ts'}, {name: 'param', type:'string', importPath: '-----no-import-path----'}],
 *  publicMethods: ['future', 'now']
 * }
 * @param fileName the name of the file (required by ts API)
 * @param fileContents contents of the file
 */
function describeSource(fileName, fileContents) {
    const sourceFile = ts.createSourceFile(fileName, fileContents, ts.ScriptTarget.ES2015, true);
    const description = read(sourceFile);
    const enrichedDescription = description.map(r => (0, types_1.isClassDescription)(r)
        ? Object.assign(Object.assign({}, r), { constructorParams: addImportPaths(r.constructorParams, fileContents) }) : r);
    return enrichedDescription;
}
exports.describeSource = describeSource;
function read(node) {
    let result = [];
    if (isExportedClass(node)) {
        const classDeclaration = node;
        result = [
            {
                type: 'class',
                name: classDeclaration.name != null ? classDeclaration.name.getText() : 'default',
                constructorParams: readConstructorParams(node),
                publicMethods: readPublicMethods(node)
            }
        ];
    }
    if (isExportedFunction(node)) {
        const func = node;
        result = [
            {
                type: 'function',
                name: func.name != null ? func.name.getText() : 'anonymousFunction'
            }
        ];
    }
    ts.forEachChild(node, n => {
        const r = read(n);
        if (r && r.length > 0) {
            result = result.concat(r);
        }
    });
    return result;
}
function readConstructorParams(node) {
    let params = [];
    ts.forEachChild(node, node => {
        if (node.kind === ts.SyntaxKind.Constructor) {
            const constructor = node;
            params = constructor.parameters.map(p => ({
                name: p.name.getText(),
                type: (p.type && p.type.getText()) || 'any' // the type of constructor param or any if not passe
            }));
        }
    });
    return params;
}
function readPublicMethods(node) {
    let publicMethods = [];
    ts.forEachChild(node, node => {
        if (node.kind === ts.SyntaxKind.MethodDeclaration) {
            const method = node;
            if (methodIsPublic(method)) {
                publicMethods.push(method.name.getText());
            }
        }
    });
    return publicMethods;
}
function methodIsPublic(methodNode) {
    const flags = ts.getCombinedModifierFlags(methodNode);
    // check if the private flag is part of this binary flag - if not means the method is public
    return ((flags & ts.ModifierFlags.Private) !== ts.ModifierFlags.Private &&
        (flags & ts.ModifierFlags.Protected) !== ts.ModifierFlags.Protected);
}
function addImportPaths(params, fullText) {
    return params.map(p => {
        const match = fullText.match(new RegExp(`import.*${p.type}.*from.*('|")(.*)('|")`)) || [];
        return Object.assign(Object.assign({}, p), { importPath: match[2] }); // take the 2 match     1-st^^^  ^^2-nd
    });
}
function isExported(node, kind) {
    return (node.kind === kind &&
        node.modifiers != null &&
        node.modifiers.some(m => m.kind === ts.SyntaxKind.ExportKeyword));
}
function isExportedClass(node) {
    return isExported(node, ts.SyntaxKind.ClassDeclaration);
}
function isExportedFunction(node) {
    return isExported(node, ts.SyntaxKind.FunctionDeclaration);
}
//# sourceMappingURL=read.js.map